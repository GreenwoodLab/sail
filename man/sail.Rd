% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/oxy-models.R
\name{sail}
\alias{sail}
\title{Fit Sparse Additive Interaction Model with Strong Heredity}
\usage{
sail(x, y, e, basis = function(i) splines::bs(i, df = 5),
  group.penalty = c("gglasso", "grMCP", "grSCAD"), family = c("gaussian",
  "binomial"), center.x = TRUE, center.e = TRUE, expand = TRUE, group,
  weights, penalty.factor = rep(1, 1 + 2 * nvars),
  lambda.factor = ifelse(nobs < (1 + 2 * bscols * nvars), 0.01, 1e-04),
  lambda = NULL, alpha = 0.5, nlambda = 100, thresh = 1e-04,
  maxit = 1000, dfmax = 2 * nvars + 1, verbose = TRUE)
}
\arguments{
\item{x}{input matrix of dimension \code{n x p}, where \code{n} is the number
of subjects and p is number of X variables. Each row is an observation
vector. Can be a high-dimensional (n < p) matrix.}

\item{y}{response variable. For \code{family="gaussian"} should be a 1 column
matrix or numeric vector. For \code{family="binomial"}, should be a 1
column matrix or numeric vector with -1 for failure and 1 for success.}

\item{e}{exposure or environment vector. Must be a numeric vector. Factors
must be converted to numeric.}

\item{basis}{user defined basis expansion function. This function will be
applied to every column in \code{x}. Specify \code{function(i) i} if no
expansion is desired. Default: \code{function(i) splines::bs(i, df = 5)}.}

\item{group.penalty}{group lasso penalty. Can be one of \code{"gglasso"}
(group lasso), \code{"grMCP"} (group MCP) or \code{"grSCAD"} (group SCAD).
See references for details. Default: \code{"gglasso"}.}

\item{family}{response type. See \code{y} for details. Currently only
\code{family = "gaussian"} is implemented. Default: \code{"gaussian"}.}

\item{center.x}{should the columns of \code{x} (after basis expansion) be centered (logical).
Default: \code{TRUE}.}

\item{center.e}{should \code{e} be centered. Default: \code{TRUE}.}

\item{expand}{should \code{basis} be applied to every column of \code{x}
(logical). Set to \code{FALSE} if you want a user defined main effects
design matrix. If \code{FALSE} the \code{group} membership argument must
also be supplied. Default: \code{TRUE}.}

\item{group}{a vector of consecutive integers describing the grouping of the
coefficients. Only required when \code{expand=FALSE}.}

\item{weights}{observation weights. Default is 1 for each observation.
Currently NOT IMPLEMENTED.}

\item{penalty.factor}{Separate penalty factors can be applied to each
coefficient. This is a number that multiplies lambda to allow differential
shrinkage. Can be 0 for some variables, which implies no shrinkage, and
that variable is always included in the model. Default is 1 for all
variables. Must be of length \code{1 + 2*ncol(x)} where the first entry
corresponds to the penalty.factor for \code{e}, the next \code{ncol(x)}
entries correspond to main effects, and the following \code{ncol(x)}
entries correspond to the interactions.}

\item{lambda.factor}{The factor for getting the minimal lambda in the lambda
sequence, where \code{min(lambda) = lambda.factor * max(lambda)}.
\code{max(lambda)} is the smallest value of lambda for which all
coefficients are zero. The default depends on the relationship between
\code{N} (the number of rows in the matrix of predictors) and \code{q} (the
total number of predictors in the design matrix - including interactions).
If \code{N > q}, the default is \code{1e-4}, close to zero. If \code{N <
p}, the default is \code{0.01}. A very small value of lambda.factor will
lead to a saturated fit.}

\item{lambda}{a user supplied lambda sequence. Typically, by leaving this
option unspecified users can have the program compute its own lambda
sequence based on \code{nlambda} and \code{lambda.factor}. Supplying a
value of lambda overrides this. It is better to supply a decreasing
sequence of lambda values than a single (small) value, if not, the program
will sort user-defined lambda sequence in decreasing order automatically.
Default: \code{NULL}.}

\item{alpha}{The mixing tuning parameter, with \eqn{0<\alpha<1}. It controls
the penalization strength between the main effects and the interactions.
The penalty is defined as \deqn{\lambda(1-\alpha)(w_e|\beta_e|+ \sum w_j
||\beta||_2) + \lambda\alpha\sum w_{je} |\gamma_j|}. Larger values of
\code{alpha} will favor selection of main effects over interactions.
Smaller values of \code{alpha} will allow more interactions to enter the
final model. Default: \code{0.5}}

\item{nlambda}{the number of lambda values. Default: 100}

\item{thresh}{Convergence thresh for coordinate descent. Each
coordinate-descent loop continues until the change in the objective
function after all coefficient updates is less than thresh. Default:
\code{1e-04}.}

\item{maxit}{maximum number of outer-loop iterations allowed at fixed lambda
value. If models do not converge, consider increasing maxit. Default: 1000.}

\item{dfmax}{Limit the maximum number of variables in the model. Useful for
very large \code{q} (the total number of predictors in the design matrix -
including interactions), if a partial path is desired, Default: \code{2 * p
+ 1}.}

\item{verbose}{display progress (logical). Default: \code{TRUE}.}
}
\value{
An object with S3 class "sail", "*", where "*" is "lspath" or
  "lognet". Results are provided for converged values of lambda only.
  \describe{\item{call}{the call that produced this object}
  \item{a0}{Intercept sequence of length \code{nlambda}} \item{beta}{A nvars
  x \code{nlambda} matrix of main effects (\eqn{\beta}) coefficients, stored
  in sparse column format \code{("dgCMatrix")}} \item{alpha}{A nvars x
  \code{nlambda} matrix of interaction effects (\eqn{\alpha}) coefficients,
  stored in sparse column format \code{("dgCMatrix")}} \item{gamma}{A nvars x
  \code{nlambda} matrix of (\eqn{\gamma}) coefficients, stored in sparse
  column format \code{("dgCMatrix")}} \item{bE}{Exposure effect estimates of
  length \code{nlambda}}
  \item{active}{list of length \code{nlambda} containing character vector of selected variables}
  \item{lambda}{The actual sequence of lambda values used}
  \item{lambda2}{value for the mixing tuning parameter \eqn{0<\alpha<1}}
  \item{dfbeta}{the number of nonzero main effect coefficients for each value of lambda}
  \item{dfalpha}{the number of nonzero interaction coefficients for each value of lambda}
  \item{dfenviron}{the number of nonzero exposure (\code{e}) coefficients for each value of lambda}
  \item{dev.ratio}{The fraction of (null) deviance explained (for "lspath", this is the R-square). The deviance calculations incorporate weights if present in the model. The deviance is defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood for the saturated model (a model with a free parameter per observation). Hence dev.ratio=1-dev/nulldev.}
  \item{converged}{vector of logicals of length \code{nlambda} indicating if the algorithm converged}
  \item{nlambda}{number of converged lambdas}
  \item{design}{design matrix (X, E, X:E) of (usually) of dimension \code{n x (2*ncols*p+1)}}
  \item{nobs}{number of observations}
  \item{nvars}{number of main effect variables}
  \item{vnames}{character of variable names for main effects}
  \item{ncols}{an integer of basis for each column of x if \code{expand=TRUE}, or an integer vector of basis for each variable if \code{expand=FALSE}}
  \item{center.x}{were the columns of x (after expansion) centered?}
  \item{center.e}{was \code{e} centered?}
  \item{basis}{user defined basis expansion function}
  \item{expand}{was the basis function applied to each column of x?}
  \item{group}{a vector of consecutive integers describing the grouping of the coefficients. Only if expand=FALSE}
  \item{interaction.names}{character vector of names of interaction variables}
  \item{main.effect.names}{character vector of names of main effect variables}
  }
}
\description{
function to fit the Strong Heredity Additive Interaction Model
  for a sequence of tuning parameters. This is a penalized regression method
  that ensures the interaction term is non-zero only if its corresponding
  main-effects are non-zero. This model only considers the interactions
  between a single exposure (E) variable and a high-dimensional matrix (X).
  This is similar to a varying-coefficient model.
}
\details{
DETAILS
}
\examples{
\dontrun{
if(interactive()){
 #EXAMPLE1
 }
}
}
\references{
Breheny P and Huang J (2015). Group descent algorithms for
  nonconvex penalized linear and logistic regression models with grouped
  predictors. Statistics and Computing, 25: 173-187.

Yang Y, Zou H. A fast unified algorithm for solving group-lasso
  penalize learning problems. Statistics and Computing. 2015 Nov
  1;25(6):1129-41.

Bhatnagar SR, Yang Y, Greenwood CMT. Sparse additive interaction
  models with the strong heredity property (2018+). Preprint.
}
\seealso{
\code{\link[splines]{bs}} \code{\link{cv.sail}}
}
\author{
Sahir Bhatnagar

  Maintainer: Sahir Bhatnagar \email{sahir.bhatnagar@gmail.com}
}
